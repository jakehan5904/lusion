<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lusion Style Fixed</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
        }

        /* 3D 캔버스: z-index 문제를 확실히 해결하기 위해 fixed로 배치 */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 0; /* 배경 */
            pointer-events: none; /* 마우스가 통과해서 글씨 선택 가능 */
        }

        main {
            position: relative;
            z-index: 10; /* 3D보다 위에 글씨 배치 */
        }

        section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 10vw;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        h1 {
            font-size: 8vw;
            line-height: 1;
            margin: 0;
            mix-blend-mode: exclusion;
        }

        p {
            font-size: 1.2rem;
            color: #aaa;
            max-width: 600px;
            margin-top: 20px;
            line-height: 1.6;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 2rem;
            margin-top: 4rem;
        }

        .stat-item h3 { font-size: 3rem; margin: 0; }
        .stat-item span { color: #666; font-size: 0.9rem; text-transform: uppercase; }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <main>
        <section>
            <p style="color: #666; text-transform: uppercase; letter-spacing: 2px;">Fixed Version</p>
            <h1>Immersive<br>Interactive<br>Web.</h1>
            <p>
                이제 3D 오브젝트가 보일 겁니다.<br>
                마우스를 움직여보세요. (따라옵니다)<br>
                스크롤을 내려보세요. (회전합니다)
            </p>
        </section>

        <section>
            <h1>Smooth<br>Scroll.</h1>
            <p>
                부드러운 스크롤(Lenis)이 적용되어 있습니다.<br>
                일반적인 웹사이트보다 스크롤이 묵직하고 부드럽게 멈추는 느낌을 확인해보세요.
            </p>
        </section>

        <section>
            <div class="stats-grid">
                <div class="stat-item"><h3>3D</h3><span>WebGL</span></div>
                <div class="stat-item"><h3>60</h3><span>FPS</span></div>
                <div class="stat-item"><h3>100%</h3><span>Interactive</span></div>
            </div>
        </section>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@studio-freight/lenis@1.0.42/dist/lenis.min.js"></script>

    <script>
        // 에러 방지를 위한 안전 장치
        try {
            // --- 1. Lenis 스무스 스크롤 설정 ---
            const lenis = new Lenis({
                duration: 1.2,
                easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
                smooth: true
            });

            function raf(time) {
                lenis.raf(time);
                requestAnimationFrame(raf);
            }
            requestAnimationFrame(raf);

            // --- 2. Three.js 설정 ---
            const scene = new THREE.Scene();
            // 배경색을 CSS와 일치시킴 (중요)
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            const renderer = new THREE.WebGLRenderer({ antialias: true }); // alpha 제거하고 background로 처리
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            const container = document.getElementById('canvas-container');
            container.appendChild(renderer.domElement);

            // --- 3. 오브젝트 생성 (가장 잘 보이는 흰색 입자) ---
            const geometry = new THREE.TorusKnotGeometry(12, 3, 100, 16);
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                sizeAttenuation: true
            });
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // --- 4. 마우스 + 스크롤 통합 인터랙션 ---
            
            // 마우스 변수
            let mouseX = 0;
            let mouseY = 0;
            let targetX = 0;
            let targetY = 0;

            const windowHalfX = window.innerWidth / 2;
            const windowHalfY = window.innerHeight / 2;

            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX - windowHalfX);
                mouseY = (event.clientY - windowHalfY);
            });

            // 스크롤 변수
            let scrollY = 0;
            lenis.on('scroll', (e) => {
                scrollY = e.scroll;
            });

            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                
                const time = clock.getElapsedTime();

                // 마우스 반응 (부드러운 추적)
                targetX = mouseX * 0.001;
                targetY = mouseY * 0.001;
                
                particles.rotation.y += 0.05 * (targetX - particles.rotation.y);
                particles.rotation.x += 0.05 * (targetY - particles.rotation.x);

                // 스크롤 반응 (추가 회전)
                // 마우스로 돌리는 와중에 스크롤 내리면 더 빨리 돔
                particles.rotation.z = time * 0.1 + (scrollY * 0.005);

                // 스크롤 시 약간의 줌인/줌아웃 효과
                particles.position.z = Math.sin(time * 0.5) * 5 + (scrollY * 0.01);

                renderer.render(scene, camera);
            }
            animate();

            // 리사이즈
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

        } catch (error) {
            console.error("Three.js 혹은 Lenis 로드 실패:", error);
            alert("라이브러리 로딩에 실패했습니다. 인터넷 연결을 확인하거나 브라우저 콘솔(F12)을 확인해주세요.");
        }
    </script>
</body>
</html>